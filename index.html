<!doctype html>
<html lang="es">

	<head>
		<meta charset="utf-8">

		<title>Arreglos y Matrices</title>

		<meta name="description" content="Arrays and Matrices">
		<meta name="author" content="Javier Guaje">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/white.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/dark-blue.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
                
<section data-markdown>
	# Arreglos & Matrices
	#####Javier Guaje
</section>
<section data-markdown>
	# Vectores o Arreglos Unidimensionales
</section>
<section>
	<section data-markdown>
		## Vectores
	</section>

	<section>
		<h2>Vectores: Ejemplo</h2>

		<p>
			$$v = [2, 4, 55, -3, -6.99]$$
		</p>

		<p class="fragment">
			La anterior quintupla de elementos denotada por la expresión \(v\), es un vector.
		</p>
	</section>

	<section>
		<h2>Vectores: Definición</h2>

		<p>
			<b>Vector</b>: Es una \(n\)-tupla de \(n\) objetos llamados las <b>componentes</b> del vector, los cuales son elementos que pertenecen a un mismo conjunto.
		</p>
	</section>

	<section>
		<h2>Vectores: Definición</h2>

		<p>
			En general, un vector \(v\) se puede denotar de la siguiente forma:

			$$v = (v_1, v_2, v_3, \dots, v_n)$$
		</p>

		<p class="fragment">
			donde el vector está constituido por \(n\) componentes de un conjunto genérico \(\mathcal{V}\). Si \(v \in \mathcal{V^n}\), entonces el arreglo se dice que es \(n\)-dimensional o de tamaño \(n\).
		</p>
	</section>

	<section>
		<h2>Vectores: Ejemplo</h2>

		<p>
			El siguiente vector de tamaño 2 pertenece a \(\mathbb{Z}^2\) y tiene una notación particular la cual es \(\textbf{1}_\textbf{2}\).
		</p>

		<p class="fragment">
			$$\textbf{1}_\textbf{2} = [1, 1]$$
		</p>
	</section>

	<section>
		<h2>Vectores: Componentes</h2>

		<p>
			Para referirse a una componente en particular, usamos la notación "\(i\)-ésima componente". Esto significa que el objeto es la componente ubicada en la posición \(i\), se denota por la expresión \(v_i\).
		</p>
	</section>

	<section>
		<h2>Vectores: Ejemplo</h2>

		<p>
			Sea,

			$$v = [-2.6, -0.25, 0.77]$$

			un vector en \(\mathbb{R}^3\).
		</p>

		<p class="fragment">
			Entonces los componentes del vector \(v\) son:
		</p>

		<ul>
			<li class="fragment">\(v_1\) = -2.6</li>
			<li class="fragment">\(v_2\) = -0.25</li>
			<li class="fragment">\(v_3\) = 0.77</li>
		</ul>
	</section>

	<section>
		<h2>Vectores: Conjunto</h2>

		<p>
			A partir de la notación de producto generalizado de un conjunto \(\mathcal{V}\).
		</p>

		<p class="fragment">
			$$\mathcal{V}^n = \underbrace{\mathcal{V} \times \mathcal{V} \times \mathcal{V} \times \dots \times \mathcal{V}}_\text{$n$ veces}$$
		</p>

		<p class="fragment">
			se puede obtener el conjunto de los vectores \(\mathcal{V}^∗\), el cual se define como la unión de todos los productos cartesianos del conjunto \(V\), de la siguiente manera:
		</p>

		<p class="fragment">
			$$\mathcal{V}^* = \underset{n \in \mathbb{N}}{\cup} \mathcal{V}^n$$
		</p>
	</section>
</section>
<section>
	<section data-markdown>
		## Arreglos
	</section>

	<section>
		<h2>Arreglos: Construcción</h2>

		<p>
			Si se tiene un conjunto \(\mathbb{T}\) que representa un tipo de datos y un número \(n \in \mathbb{N}\), entonces se puede construir un vector de tamaño \(n\).
		</p>
	</section>

	<section>
		<h2>Arreglos: Generalización</h2>
		
		<p>
			A partir del producto generalizado de un conjunto \(\mathbb{T}\) se puede obtener el conjunto de los arreglos \(\mathbb{T}^∗\), el cual se define como la unión de todos los productos cartesianos del conjunto \(\mathbb{T}\), de la siguiente manera:
		</p>

		<p class="fragment">
			\(\mathbb{T}^* = \underset{n \in \mathbb{N}}{\cup} \mathbb{T}^n\) y se llama el conjunto de todos los arreglos de tipo \(\mathbb{T}\).
		</p>

		<p class="fragment">
			así, el conjunto de los arreglos del tipo de datos \(\mathbb{T}\) es una colección de variables del tipo de datos \(\mathbb{T}\).
		</p>
	</section>

	<section>
		<h2>Arreglos: Nota</h2>

		<p>
			Para definir arreglos se utilizará la notación de memoria dinámica, es decir, si \(x \in \mathbb{T}^∗\) entonces el vector \(x\) se creará en tiempo de ejecución del programa.
		</p>
	</section>

	<section>
		<h2>Arreglos: Creación en C++</h2>

		<p>
			Si se quiere expresar en C++ que \(x \in \mathbb{T}^∗\) esto se escribe como \(\mathbb{T}* x\); y para reservar el espacio de memoria para todo el arreglo de tipo \(\mathbb{T}\), esto se escribe como \(x = new \mathbb{T}[n]\).
		</p>

		<p class="fragment">
			De donde, para crear un arreglo \(x\) de tamaño \(n\) y de tipo \(\mathbb{T}\) se utiliza la instrucción.
		</p>

		<p class="fragment">
			$$\mathbb{T}* x = new \mathbb{T}[n];$$
		</p>
	</section>

	<section>
		<h2>Arreglos: Creación en Python</h2>

		<p>
			En el caso de Python los arreglos son tratados como cualquier variable. Por lo tanto, solo cobra sentido la reservación de espacio en memoria.
		</p>

		<p class="fragment">
			Así, para crear un arreglo \(x\) de tamaño \(n\) se utiliza la instrucción.
		</p>

		<p class="fragment">
			$$x = [0] * n$$
		</p>
	</section>

	<section data-markdown>
		## Arreglos: Inicialización

		Un arreglo también puede ser creado asignando valores a los componentes.
	</section>

	<section>
		<h2>Arreglos: Inicialización en C++</h2>

		<p>
			Si se quiere expresar en C++ el vector \(v = [2, 4, 55, -3, -6.99]\) esto se escribe como \(float~v[] = \{2, 4, 55, -3, -6.99\}\);
		</p>

		<p class="fragment">
			De donde, podemos generalizar para crear arreglos de tipo \(\mathbb{T}\) mediante la instrucción.
		</p>

		<p class="fragment">
			$$\mathbb{T}~v[] = \{v_1, v_2, v_3, \dots, v_n\};$$
		</p>
	</section>

	<section>
		<h2>Arreglos: Inicialización en Python</h2>

		<p>
			En el caso de Python podemos expresar el vector \(v = [2, 4, 55, -3, -6.99]\) como \(v = [2, 4, 55, -3, -6.99]\).
		</p>

		<p class="fragment">
			Así, para inicializar un arreglo \(v\) podemos utilizar la instrucción.
		</p>

		<p class="fragment">
			$$v = [v_1, v_2, v_3, \dots, v_n]$$
		</p>
	</section>

	<section>
		<h2>Arreglos: Componentes</h2>

		<ul>
			<li>
				En la gran mayoria de los lenguajes de programación la primera componente del arreglo está ubicada en la posición \(0\).
			</li>
			<li class="fragment">
				Por lo tanto, para un arreglo de tamaño \(n\) se tiene que la última componente del arreglo estará ubicada en la posición \(n − 1\).
			</li>
		</ul>
	</section>

	<section>
		<h2>Arreglos: Componentes</h2>

		<p>
			A partir de lo anterior se tiene que dado un arreglo \(x \in \mathbb{T}^∗\), para acceder a la variable almacenada en la componente \(i\) se utiliza la equivalencia:
		</p>

		<p class="fragment">
			$$x_i \equiv x[i - 1]$$
		</p>
	</section>

	<section>
		<h2>Arreglos: Componentes</h2>

		<ul>
			<li>
				Una excepción a lo anterior es el lenguaje MatLab, para el cual la primera componente del arreglo está ubicada en la posición \(1\).
			</li>
			<li class="fragment">
				Por lo tanto,  para un arreglo de tamaño \(n\) se tiene que la última componente del arreglo estará ubicada en la posición \(n\).
			</li>
		</ul>
	</section>

	<section>
		<h2>Arreglos: Componentes</h2>

		<p>
			Es decir, para acceder en MatLab a la variable almacenada en la componente \(i\) se utiliza la equivalencia:
		</p>

		<p class="fragment">
			$$x_i \equiv x[i]$$
		</p>
	</section>

	<section>
		<h2>Arreglos: Consideración en C++</h2>

		<p>
			Al igual que con las variables, al crear un arreglo mediante la forma \(\mathbb{T}* x = new \mathbb{T}[n];\) el espacio en memoria contiene basura.
		</p>

		<p class="fragment">
			Por lo tanto, es recomendable inicializar estos valores. Lo cual se puede hacer de la siguiente manera:
		</p>
	</section>

	<section data-markdown>
		## Arreglos: Consideración en C++

```cpp
#include &lt;iostream&gt;

using namespace std;

int main()
{
	int len = 3;
	float* x = new float[len];
	for(int i = 0; i < len; i++)
	{
	    x[i] = 0;
	}

	return 0;
}
```
	</section>

	<section>
		<h2>Arreglos: Ejemplo</h2>

		<p>
			Dado un conjunto, calcular la cantidad de elementos que contiene.
		</p>

		<p>
			Para resolver este problema podemos definir la siguiente función.
		</p>

		<p class="fragment">
			$$longitud : \mathbb{R}^* \rightarrow \mathbb{Z}^+$$
			$$(x) \rightarrow \sum_{i \in x} 1$$
		</p>
	</section>

	<section data-markdown>
		## Arreglos: Ejemplo en Python

```python
def longitud(x):
	r = 0
	for i in x:
	    r += 1
	return r

x = [0, 0]
print(longitud(x))
```
	</section>

	<section>
		<h2>Arreglos: Ejemplo</h2>

		<p>
			Dado un conjunto de datos, calcular el promedio de estos.
		</p>

		<p class="fragment">
			Se puede tomar el resultado de la función anterior para calcular el promedio de los elementos de un arreglo utilizando el siguiente modelo de función matemática:
		</p>

		<p class="fragment">
			$$promedio : \mathbb{R}^* \rightarrow \mathbb{R}$$
			$$(x) \rightarrow \frac{1}{longitud(x)}\sum_{i \in x} i$$
		</p>
	</section>

	<section data-markdown>
		## Arreglos: Ejemplo en Python

```python
def longitud(x):
	r = 0
	for i in x:
	    r += 1
	return r

def promedio(x):
	l = longitud(x)
	r = 0
	for i in x:
	    r += i
	return r / l

x = [1, 2, 3]
print(promedio(x))
```
	</section>

	<section data-markdown>
		## Arreglos: Ejemplo en Python

```python
def promedio(x):
	l = len(x)
	r = 0
	for i in x:
	    r += i
	return r / l

x = [1, 2, 3]
print(promedio(x))
```
	</section>

	<section>
		<h2>Arreglos: Ejemplo</h2>

		<p>
			En el caso de C++ deberemos pasar como argumento la longitud del arreglo, así:
		</p>

		<p class="fragment">
			$$promedio : \mathbb{R}^* \times \mathbb{Z}^+ \rightarrow \mathbb{R}$$
			$$(x, l) \rightarrow \frac{1}{l}\sum_{i \in x} i$$
		</p>
	</section>

	<section data-markdown>
		## Arreglos: Ejemplo en C++

```cpp
#include &lt;iostream&gt;

using namespace std;

float promedio(float* x, int l)
{
	float r = 0;
	for(int i = 0; i < l; i++)
	{
	    r += x[i];
	}
	return r / l;
}

int main()
{
	float x[] = {1, 2, 3};
	cout << promedio(x, 3) << endl;

	return 0;
}
```
	</section>

	<section>
		<h2>Arreglos: Consideraciones</h2>

		<ul>
			<li>
				En C++, en caso de que se quiera acceder a una componente mayor o igual al \(n\)-ésimo el valor retornado será lo que exista en ese momento en memoria.
			</li>

			<li class="fragment">
				En Python, en caso de que se quiera acceder a una componente mayor o igual al \(n\)-ésimo el interprete arrojará un error que indica que ese índice esta fuera de los limites del arreglo.
			</li>

			<li class="fragment">
				Si se quiere acceder a una componente menor a \(0\), ocurre algo similar a lo descrito anteriormente.
			</li>
		</ul>
	</section>
</section>
<section>
	<section data-markdown>
		## Introducción a las estructuras de datos
	</section>

	<section data-markdown>
		## Estructuras de datos: Ejemplo en C++

```cpp
#include &lt;iostream&gt;

using namespace std;

class Arreglo
{
	private:
	    float* x;
	    int l;
	    float max;
	    float min;

	public:
	    float* inicializar(int dim);
	    int insertar(float val);
	    int longitud();
	    float maximo();
	    float minimo();
};
```
	</section>

	<section data-markdown>
		## Estructuras de datos: Ejemplo en C++

```cpp
float* Arreglo::inicializar(int dim)
{
	x = new float[dim];
	for(int i = 0; i < dim; i++)
	{
	    x[i] = 0;
	}
	l = 0;
	max = x[0];
	min = x[0];
	return x;
}
```
	</section>

	<section data-markdown>
		## Estructuras de datos: Ejemplo en C++

```cpp
int Arreglo::insertar(float val)
{
	x[l] = val;
	if(x[l] > max)
	    max = x[l];
	if(x[l] < min)
	    min = x[l];
	return l++;
}
```
	</section>

	<section data-markdown>
		## Estructuras de datos: Ejemplo en C++

```cpp
int Arreglo::longitud()
{
	return l;
}

float Arreglo::maximo()
{
	return max;
}

float Arreglo::minimo()
{
	return min;
}
```
	</section>

	<section data-markdown>
		## Estructuras de datos: Ejemplo en C++

```cpp
int main()
{
	Arreglo a;
	float* x;
	int p1;
	int p2;
	int l = 3;
	
	x = a.inicializar(l);
	for(int i = 0; i < l; i++)
	{
	    cout << x[i] << endl;
	}
	
	p1 = a.insertar(-0.15);
	cout << endl << p1 << endl;
	cout << a.longitud() << endl;
	cout << a.maximo() << endl;
	cout << a.minimo() << endl << endl;
	
	p2 = a.insertar(33);
	cout << p2 << endl;
	cout << a.longitud() << endl;
	cout << a.maximo() << endl;
	cout << a.minimo() << endl << endl;
	
	for(int i = 0; i < l; i++)
	{
	    cout << x[i] << endl;
	}

	return 0;
}
```
	</section>

	<section data-markdown>
		<script type="text/template">
		## Estructuras de datos en Python: Listas []

		- Las listas son secuencias mutables, i.e., que su contenido puede cambiar.
		- <!-- .element: class="fragment" -->
		Generalmente son usadas para almacenar colecciones de objetos homogeneos.
		- <!-- .element: class="fragment" -->
		Al igual que el concepto de tipado dinámico empleado en la declaración de variables. En python, las listas también son manejadas de manera dinámica.
		</script>
	</section>

	<section>
		<h2>Estructuras de datos en Python: Listas []</h2>

		<p>
			Esto quiere decir que no es necesario fijar el tamaño de la lista al momento de su creación, así:
		</p>

		<p class="fragment">
			$$x = []$$
		</p>
	</section>

	<section>
		<h2>Estructuras de datos en Python: Listas []</h2>

		<p>
			Adicionalmente las listas poseen los siguientes métodos:
		</p>

		<ul>
			<li class="fragment">
				lista.<b>append(x)</b>: Agrega un elemento al final de la lista. Esto es equivalente a \(a[len(a):] = [x]\).
			</li>
			<li class="fragment">
				lista.<b>extend(L)</b>: Extiende la lista agregando un conjunto de elementos o sublista a la lista dada. Esto es equivalente a \(a[len(a):] = L\).
			</li>
			<li class="fragment">
				lista.<b>insert(i, x)</b>: Inserta el elemento \(x\) en la posición \(i\).
			</li>
			<li class="fragment">
				lista.<b>remove(x)</b>: Remueve el primer elemento de la lista cuyo valor sea igual a \(x\). Lanza un error si el elemento no está en la lista.
			</li>
		</ul>
	</section>

	<section>
		<h2>Estructuras de datos en Python: Listas[]</h2>

		<ul>
			<li>
				lista.<b>pop([i])</b>: Remueve y retorna el elemento de la posición \(i\). Si no se especifica un indice, i.e., a.pop(). Entonces se remueve y se retorna el último elemento. (Los paréntesis cuadrados alrededor de \(i\) en la firma del método denotan que ese argumento es opcional.)
			</li>
			<li class="fragment">
				lista.<b>clear()</b>: Remueve todos los elementos de la lista.
			</li>
			<li class="fragment">
				lista.<b>sort()</b>: Ordena los elementos de la lista.
			</li>
			<li class="fragment">
				lista.<b>reverse()</b>: Invierte el orden de los elementos de la lista.
			</li>
			<li class="fragment">
				lista.<b>copy()</b>: Retorna una copia de la lista.
			</li>
		</ul>
	</section>

	<section data-markdown>
		<script type="text/template">
		## Estructuras de datos en Python: Tuplas ()

		- Las tuplas son secuencias inmutables, i.e., que su contenido no puede cambiar.
		- <!-- .element: class="fragment" -->
		Generalmente son usadas para almacenar colecciones de objetos heterogeneos.
		</script>
	</section>

	<section>
		<h2>Estructuras de datos en Python: Secuencias</h2>

		<ul>
			<li>
				x <b>in</b> s: Retorna <b>True</b> si un elemento de \(s\) es igual a \(x\). De lo contrario retorna <b>False</b>.
			</li>
			<li class="fragment">
				x <b>not in</b> s: Retorna <b>False</b> si un elemento de \(s\) es igual a \(x\). De lo contrario retorna <b>True</b>.
			</li>
			<li class="fragment">
				s <b>+</b> t: Ejecuta la concatenación de \(s\) y \(t\).
			</li>
			<li class="fragment">
				s <b>*</b> n or n <b>*</b> s: Retorna una secuencia con \(n\) copias de la secuencia \(s\) concatenadas.
			</li>
			<li class="fragment">
				s<b>[i]</b>: \(i\)-ésimo elemento de la secuencia \(s\), tomando como origen el indice \(0\).
			</li>
			<li class="fragment">
				s<b>[i:j]</b>: Retorna la subsecuencia de elementos de \(s\) comprendidos entre los índices \(i\) y \(j\).
			</li>
		</ul>
	</section>

	<section>
		<h2>Estructuras de datos en Python: Secuencias</h2>

		<ul>
			<li>
				s<b>[i:j:k]</b>: Retorna la subsecuencia de elementos de \(s\) comprendidos entre los índices \(i\) y \(j\), haciendo un paso de \(k\).
			</li>
			<li class="fragment">
				<b>len(s)</b>: Retorna la longitud de la secuencia \(s\).
			</li>
			<li class="fragment">
				<b>min(s)</b>: Retorna el menor elemento de la secuencia \(s\).
			</li>
			<li class="fragment">
				<b>max(s)</b>: Retorna el mayor elemento de la secuencia \(s\).
			</li>
			<li class="fragment">
				s.<b>index(x)</b>: Retorna el índice de la primera ocurrencia de \(x\) en la secuencia \(s\). Lanza un error si el elemento no está en la secuencia.
			</li>
			<li class="fragment">
				s.<b>count(x)</b>: Retorna el número de ocurrencias de \(x\) en la secuencia \(s\).
			</li>
		</ul>
	</section>

	<section data-markdown>
		<script type="text/template">
		## Estructuras de datos en Python: Conjuntos {}

		- Un conjunto es una colección no ordenada de distintos elementos únicos.
		- <!-- .element: class="fragment" -->
		Usos conocidos incluyen las pruebas de membresía, eliminación de elementos duplicados en una secuencia y calculo de operaciones matemáticas como la intersección, unión, diferencia y diferencia simétrica.
		</script>
	</section>

	<section>
		<h2>Estructuras de datos en Python: Conjuntos {}</h2>

		<p>
			Las operaciones que provee la estructura conjunto son las siguientes:
		</p>

		<ul>
			<li class="fragment">
				<b>len(s)</b>: Retorna la cardinalidad de \(s\).
			</li>
			<li class="fragment">
				x <b>in</b> s: Prueba la membresía de \(x\) en \(s\).
			</li>
			<li class="fragment">
				x <b>not in</b> s: Prueba la no-membresía de \(x\) en \(s\).
			</li>
			<li class="fragment">
				conjunto.<b>isdisjoint(other)</b>: Retorna <b>True</b> si el conjunto no tiene elementos en común con \(other\). En otras palabras, dos (\(2\)) conjuntos son disyuntos si y solo si su intersección es el conjunto vacio.
			</li>
		</ul>
	</section>

	<section>
		<h2>Estructuras de datos en Python: Conjuntos {}</h2>

		<ul>
			<li>
				conjunto.<b>issubset(other)</b>: Prueba que cada elemento en el conjunto también pertenece a \(other\).
			</li>
			<li class="fragment">
				conjunto.<b>issuperset(other)</b>: Prueba que cada elemento de \(other\) también pertenece al conjunto.
			</li>
			<li class="fragment">
				conjunto.<b>union(other, ...)</b>: Retorna un nuevo conjunto con los elementos del conjunto y de \(other\).
			</li>
			<li class="fragment">
				conjunto.<b>intersection(other, ...)</b>: Retorna un nuevo conjunto con los elementos que tienen en común el conjunto y \(other\).
			</li>
		</ul>
	</section>

	<section>
		<h2>Estructuras de datos en Python: Conjuntos{}</h2>

		<ul>
			<li>
				conjunto.<b>difference(other, ...)</b>: Retorna un nuevo conjunto con los elementos que estan en el conjunto que no están en \(other\).
			</li>
			<li class="fragment">
				conjunto.<b>symmetric_difference(other)</b>: Retorna un nuevo conjunto con los elementos que están en conjunto o que están en \(other\), pero no en ambos.
			</li>
			<li class="fragment">
				conjunto.<b>copy()</b>: Retorna un nuevo conjunto con una copia de conjunto.
			</li>
		</ul>
	</section>
</section>
<section data-markdown>
	# Matrices o Arreglos Multidimensonales
</section>
<section>
	<section data-markdown>
		## Matrices
	</section>

	<section>
		<h2>Matrices: Ejemplo</h2>

		<p>
			$$
			X = \begin{bmatrix}
			1 & 3 & 7 & -2 & 8 \\
			9 & 11 & 5 & 6 & 4 \\
			6 & -2 & -1 & 1 & 1 \\
			\end{bmatrix}
			$$
		</p>

		<p class="fragment">
			La anterior tabla de elementos denotada por la expresión \(X\), es una matriz.
		</p>
	</section>

	<section>
		<h2>Matrices: Definición</h2>

		<p>
			Una matriz es un arreglo rectangular de objetos, los cuales pertenecen a un mismo conjunto.
		</p>
	</section>

	<section>
		<h2>Matrices: Definición</h2>

		<p>
			En general, una matriz \(X\) se puede denotar de la siguiente forma:

			$$
			X = \begin{bmatrix}
			x_{11} & x_{12} & x_{13} & \cdots & x_{1(m - 1)} & x_{1m} \\
			x_{21} & x_{22} & x_{23} & \cdots & x_{2(m - 1)} & x_{2m} \\
			x_{31} & x_{32} & x_{33} & \cdots & x_{3(m - 1)} & x_{3m} \\
			\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
			x_{(n - 1)1} & x_{(n - 1)2} & x_{(n - 1)3} & \cdots & x_{(n - 1)(m - 1)} & x_{(n - 1)m} \\
			x_{n1} & x_{n2} & x_{n3} & \cdots & x_{n(m - 1)} & x_{nm} \\
			\end{bmatrix}
			$$
		</p>

		<p class="fragment">
			donde la matriz está compuesta por \(n\) filas y \(m\) columnas, a esta matriz se le dice que es de tamaño \(n \times m\).
		</p>
	</section>

	<section>
		<h2>Matrices: Ejemplo</h2>

		<p>
			La siguiente matriz es una matriz de tamaño \(4 \times 5\).
		</p>

		<p class="fragment">
			$$
			X = \begin{bmatrix}
			0 & 0 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & 0 \\
			0 & 0 & 0 & 0 & 0 \\
			\end{bmatrix}
			$$
		</p>
	</section>

	<section>
		<h2>Matrices: Componentes</h2>

		<ul>
			<li>
				A los objetos de la matriz se les llaman <b>componentes</b> o <b>entradas</b> de la matriz.
			</li>
			<li class="fragment">
				Para referirse a una componente en particular, a ésta se le dice que es la componente en la posición \((i, j)\).
			</li>
			<li>
				<p class="fragment">
					Esto significa que el objeto es la componente ubicada en la fila \(i\) y en el columna \(j\).
				</p>
				<p class="fragment">
					El cual se denota por la expresión \(x_{ij}\).
				</p>
			</li>
		</ul>
	</section>

	<section>
		<h2>Matrices: Componentes</h2>

		<p>
			De lo anterior se tiene que:
		</p>

		<p class="fragment">
			$$
			X = \begin{bmatrix}
			x_{11} & \cdots & x_{1j} & \cdots & x_{1m} \\
			\vdots & \ddots & \vdots & \ddots & \vdots \\
			x_{i1} & \cdots & \fbox{\(x_{ij}\)} & \cdots & x_{im} \\
			\vdots & \ddots & \vdots & \ddots & \vdots \\
			x_{n1} & \cdots & x_{nj} & \cdots & x_{nm} \\
			\end{bmatrix}
			$$
		</p>
	</section>

	<section>
		<h2>Matrices: Ejemplo</h2>

		<p>
			Para la matriz,

			$$
			X = \begin{bmatrix}
			2 & -1 \\
			-\frac{1}{5} & \sqrt{2} \\
			3.14 & \pi \\
			\end{bmatrix}
			$$

			de tamaño \(3 \times 2\).
		</p>

		<p class="fragment">
			Se tiene que sus componentes son:
		</p>

		<div style="float: left; width: 50%;">
			<ul>
				<li class="fragment">\(x_{11}\) = 2</li>
				<li class="fragment">\(x_{21}\) = \(-\frac{1}{5}\)</li>
				<li class="fragment">\(x_{31}\) = 3.14</li>
			</ul>
		</div>
		<div style="float: right; width: 50%;">
			<ul>
				<li class="fragment">\(x_{12}\) = -1</li>
				<li class="fragment">\(x_{22}\) = \(\sqrt{2}\)</li>
				<li class="fragment">\(x_{32}\) = \(\pi\)</li>
			</ul>
		</div>
	</section>

	<section data-markdown>
		## Matrices: Definiciones Alternativas

		Una forma de entender la estructura interna de una matriz distinta a la definida previamente, es la de interpretarla como _un arreglo de arreglos_, esto es, verla como un arreglo cuyas componentes son a su vez otros arreglos; como se explica a continuación:
	</section>

	<section>
		<h2>Matrices: Definición por Vectores Fila</h2>

		<p>
			Una matriz puede verse como un vector columna cuyas componentes son vectores fila, así una matriz es un vector de tamaño \(n \times 1\) cuyas componentes son vectores de tamaño \(1 \times m\).
		</p>

		<p class="fragment">
			$$
			X = \begin{bmatrix}
			[x_{11} & x_{12} & x_{13} & \cdots & x_{1m}] \\
			&& \vdots \\
			[x_{i1} & x_{i2} & x_{i3} & \cdots & x_{im}] \\
			&& \vdots \\
			[x_{n1} & x_{n2} & x_{n3} & \cdots & x_{nm}] \\
			\end{bmatrix}
			$$
		</p>
	</section>

	<section>
		<h2>Matrices: Definición por Vectores Columna</h2>

		<p>
			Una matriz puede verse como un vector fila cuyas componentes son vectores columna, así una matriz es un vector de tamaño \(1 \times m\) cuyas componentes son vectores de tamaño \(n \times 1\).
		</p>

		<p class="fragment">
			$$
			X = \begin{bmatrix}
			\begin{bmatrix}
			x_{11} \\ x_{21} \\ x_{31} \\ \vdots \\ x_{n1}
			\end{bmatrix}
			\cdots
			\begin{bmatrix}
			x_{1j} \\ x_{2j} \\ x_{3j} \\ \vdots \\ x_{nj}
			\end{bmatrix}
			\cdots
			\begin{bmatrix}
			x_{1m} \\ x_{2m} \\ x_{3m} \\ \vdots \\ x_{nm}
			\end{bmatrix}
			\end{bmatrix}
			$$
		</p>
	</section>

	<section>
		<h2>Matrices: Conjunto</h2>

		<p>
			A partir del concepto de arreglo y usando la definición de matrices por vectores fila se puede ahora definir el conjunto de las matrices \(\mathbb{T}^{∗∗}\) como la unión de todos los productos cartesianos del conjunto de los arreglos del conjunto \(\mathbb{T}\), de la siguiente manera:
		</p>

		<p class="fragment">
			$$\mathbb{T}^{**} = \underset{n \in \mathbb{N}}{\cup} \left(\underset{m \in \mathbb{N}}{\cup} (\mathbb{T}^m)^T \right)^n$$
		</p>

		<p class="fragment">
			El producto externo debe entenderse como un producto cartesiano que genera vectores columna y que internamente genera vectores fila, así como en la definición por vectores fila.
		</p>
	</section>

	<section>
		<h2>Matrices: Conjunto</h2>

		<p>
			Un elemento genérico del conjunto \(\mathbb{T}^{∗∗}\) es de la forma \(\left((\mathbb{T}^m)^T\right)^n\), donde \(n\) es el número de filas y \(m\) es el número de columnas. Para abreviar, de aquí en adelante se utilizará la notación:
		</p>

		<p class="fragment">
			$$\left((\mathbb{T}^m)^T\right)^n \Leftrightarrow \mathbb{T}^{n \times m}$$
		</p>
	</section>
</section>
<section>
	<section data-markdown>
		## Arreglos Multidimensionales
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Construcción</h2>

		<p>
			Si se tiene un conjunto \(\mathbb{T}\) que representa un tipo de datos y los números \(n \in \mathbb{N}\) y \(m \in \mathbb{N}\), entonces se puede construir una matriz de tamaño \(n \times m\).
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Generalización</h2>
		
		<p>
			A partir del producto generalizado de un conjunto \(\mathbb{T}\) se puede obtener el conjunto de las matrices \(\mathbb{T}^{**}\), el cual se define como la unión de todos los productos cartesianos del conjunto de los arreglos del conjunto \(\mathbb{T}\), de la siguiente manera:
		</p>

		<p class="fragment">
			\(\mathbb{T}^{**} = \underset{n \in \mathbb{N}}{\cup} \left(\underset{m \in \mathbb{N}}{\cup} (\mathbb{T}^m)^T \right)^n\) y se llama el conjunto de todos los arreglos de tipo \((\mathbb{T}^m)^T\).
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Nota</h2>

		<p>
			De la misma manera que los arreglos, para definir arreglos multidimensionales se utilizará la notación de memoria dinámica, es decir, si \(x \in \mathbb{T}^{**}\) entonces la matriz \(X\) se creará en tiempo de ejecución del programa.
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Creación en C++</h2>

		<p>
			Si se quiere expresar en C++ que \(x \in \mathbb{T}^{**}\) esto se escribe como \(\mathbb{T}**~X\); y para reservar el espacio de memoria para todo el arreglo de tipo \(\mathbb{T}\), esto se escribe como \(X = new \mathbb{T}*[n]\). Seguido de las instrucciones \(for(int~i = 0; i < n; i++) X[i] = new \mathbb{T}[m];\)
		</p>

		<p class="fragment">
			De donde, para crear un arreglo \(X\) de tamaño \(n \times m\) y de tipo \(\mathbb{T}\) se utilizan las instrucciones.
		</p>

		<p class="fragment">
			$$\mathbb{T}**~X = new \mathbb{T}*[n];$$
			$$for(int~i = 0; i < n; i++)$$
			$$X[i] = new \mathbb{T}[m];$$
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Creación en Python</h2>

		<p>
			En el caso de Python las matrices son tratados como cualquier variable. Por lo tanto, solo cobra sentido la reservación de espacio en memoria.
		</p>

		<p class="fragment">
			Así, para crear una matriz \(X\) de tamaño \(n \times m\) se utiliza la instrucción.
		</p>

		<p class="fragment">
			$$X = [[0] * m~for~i~in~range(n)]$$
		</p>
	</section>

	<section data-markdown>
		## Arreglos Multidimensionales: Inicialización

		Una matriz también puede ser creada asignando valores a los componentes.
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Inicialización en C++</h2>

		<p>
			Si se quiere expresar en C++ la matriz
		</p>

		<p>
			$$
			X = \begin{bmatrix}
			1 & 3 \\
			9 & 11 \\
			6 & -2 \\
			\end{bmatrix}
			$$
		</p>
			
		<p class="fragment">
			esto se escribe como \(int~X[3][2] = \{\{1, 3\}, \{9, 11\}, \{6, -2\}\}\);
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Inicialización en C++</h2>

		<p>
			De donde, podemos generalizar para crear matrices de tipo \(\mathbb{T}\) mediante la instrucción.
		</p>

		<p class="fragment">
			$$\mathbb{T}~X[n][m] = \{$$
			$$\{x_{11}, x_{12}, \cdots, x_{1m}\},$$
			$$\vdots,$$
			$$\{x_{i1}, x_{i2}, \cdots, x_{im}\},$$
			$$\vdots,$$
			$$\{x_{n1}, x_{n2}, \cdots, x_{nm}\}$$
			$$\};$$
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Inicialización en Python</h2>

		<p>
			En el caso de Python podemos expresar la matriz
		</p>

		<p>
			$$
			X = \begin{bmatrix}
			1 & 3 \\
			9 & 11 \\
			6 & -2 \\
			\end{bmatrix}
			$$
		</p>
			
		<p class="fragment">
			como \(X = [[1, 3], [9, 11], [6, -2]]\)
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Inicialización en Python</h2>

		<p>
			Así, para inicializar una matriz \(X\) podemos utilizar la instrucción.
		</p>

		<p class="fragment">
			$$X = [$$
			$$[x_{11}, x_{12}, \cdots, x_{1m}],$$
			$$\vdots,$$
			$$[x_{i1}, x_{i2}, \cdots, x_{im}],$$
			$$\vdots,$$
			$$[x_{n1}, x_{n2}, \cdots, x_{nm}]$$
			$$]$$
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Componentes</h2>

		<ul>
			<li>
				En la gran mayoria de los lenguajes de programación la primera componente de una matriz está ubicada en la posición \(0, 0\).
			</li>
			<li class="fragment">
				Por lo tanto, para una matriz de tamaño \(n \times m\) se tiene que la última componente de la matriz estará ubicada en la posición \(n − 1, m - 1\).
			</li>
		</ul>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Componentes</h2>

		<p>
			A partir de lo anterior se tiene que dada una matriz \(x \in \mathbb{T}^{**}\), para acceder a la variable almacenada en la componente \(i, j\) se utiliza la equivalencia:
		</p>

		<p class="fragment">
			$$x_{ij} \equiv x[i - 1][j - 1]$$
		</p>
	</section>

	<section>
		<h2>Arreglos Mulltidimensionales: Componentes</h2>

		<ul>
			<li>
				Una excepción a lo anterior es el lenguaje MatLab, para el cual la primera componente de la matriz está ubicada en la posición \(1, 1\).
			</li>
			<li class="fragment">
				Por lo tanto,  para una matriz de tamaño \(n \times m\) se tiene que la última componente del arreglo estará ubicada en la posición \(n, m\).
			</li>
		</ul>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Componentes</h2>

		<p>
			Es decir, para acceder en MatLab a la variable almacenada en la componente \(i, j\) se utiliza la equivalencia:
		</p>

		<p class="fragment">
			$$x_{ij} \equiv x[i][j]$$
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Consideración en C++</h2>

		<p>
			Al igual que con las variables, al crear una matriz mediante la forma \(\mathbb{T}**~X = new \mathbb{T}*[n];\) \(for(int~i = 0; i < n; i++)\) \(X[i] = new \mathbb{T}[m];\) el espacio en memoria contiene basura.
		</p>

		<p class="fragment">
			Por lo tanto, es recomendable inicializar estos valores. Lo cual se puede hacer de la siguiente manera:
		</p>
	</section>

	<section data-markdown>
		## Arreglos Multidimensionales: Consideración en C++

```cpp
#include &lt;iostream&gt;

using namespace std;

int main()
{
	int fil = 3;
	int col = 2;
	
	int** X = new int*[fil];
	for(int i = 0; i < fil; i++)
	    X[i] = new int[col];
	
	for(int i = 0; i < fil; i++)
	{
	    for(int j = 0; j < col; j++)
	    {
	        X[i][j] = 0;
	    }
	}

	return 0;
}
```
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			Dado un sistema de ecuaciones de dos ecuaciones con dos incógnitas
		</p>

		<p>
			$$ax + by = c$$
			$$dx + ey = f$$
		</p>

		<p class="fragment">
			este sistema de ecuaciones se puede expresar mediante matrices de la siguiente manera:
		</p>

		<p class="fragment">
			$$
			\begin{bmatrix}
			a & b \\
			d & e \\
			\end{bmatrix}
			\begin{bmatrix}
			x \\
			y \\
			\end{bmatrix}
			=
			\begin{bmatrix}
			c \\
			f \\
			\end{bmatrix}
			$$
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			una solución del sistema es una pareja \((x_0, y_0)\) tal que:
		</p>

		<p>
			\(ax_0 + by_0 = c\) y \(dx_0 + ey_0 = f\)
		</p>

		<p class="fragment">
			El sistema tiene una solución única si la expresión \(a * e − d ∗ b = 0\).
		</p>

		<p class="fragment">
			A la anterior expresión se le conoce como el determinante de la matriz, y efectivamente sirve para determinar si un sistema tiene una única solución, si no tiene o si no es única.
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			A continuación se presenta una función que permite calcular el determinante de una matriz \(2 \times 2\).
		</p>

		<p class="fragment">
			$$determinante : \mathbb{Z}^{2 \times 2} \rightarrow \mathbb{Z}$$
			$$(X) \rightarrow X_{11} * X_{22} - X_{21} * X_{12}$$
		</p>
	</section>

	<section data-markdown>
		## Arreglos Multidimensionales: Ejemplo en C++

```cpp
#include &lt;iostream&gt;

using namespace std;

float determinante(int X[2][2])
{
	return X[0][0] * X[1][1] - X[0][1] * X[1][0];
}

int main()
{
	int y = 0;
	int X[2][2] = {
	    {1, 1},
	    {1, 1}
	};
	y = determinante(X);
	
	cout << "El determinante de la matriz" << endl;
	for(int i = 0; i < 2; i++)
	{
	    for(int j = 0; j < 2; j++)
	    {
	        cout << X[i][j];
	    }
	    cout << endl;
	}
	cout << "es: " << y << endl;

	return 0;
}
```
	</section>

	<section data-markdown>
		## Arreglos Multidimensionales: Ejemplo en Python

```python
def determinante(X):
	return X[0][0] * X[1][1] - X[0][1] * X[1][0]

y = 0
X = [[1, 1], [1, 1]]
y = determinante(X);
print("El determinante de la matriz")
print(X)
print("es: " + str(y))
```
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			Una de los operaciones básicas sobre las matrices es el producto escalar. En éste se elige un valor sobre un conjunto (por ejemplo los reales \(\mathbb{R}\)) y se multiplica este valor por cada componente de la matriz.
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			Así, si \(\alpha \in \mathbb{R}\) y
		</p>

		<p class="fragment">
			$$
			X = \begin{bmatrix}
			x_{11} & x_{12} & \cdots & x_{1m} \\
			x_{21} & x_{22} & \cdots & x_{2m} \\
			\vdots & \vdots & \ddots & \vdots \\
			x_{n1} & x_{n2} & \cdots & x_{nm} \\
			\end{bmatrix}
			$$
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			entonces
		</p>

		<p class="fragment">
			$$Y = \alpha * X$$
		</p>

		<p class="fragment">
			$$
			Y = \alpha * \begin{bmatrix}
			x_{11} & x_{12} & \cdots & x_{1m} \\
			x_{21} & x_{22} & \cdots & x_{2m} \\
			\vdots & \vdots & \ddots & \vdots \\
			x_{n1} & x_{n2} & \cdots & x_{nm} \\
			\end{bmatrix}
			$$
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			$$
			Y = \begin{bmatrix}
			\alpha * x_{11} & \alpha * x_{12} & \cdots & \alpha * x_{1m} \\
			\alpha * x_{21} & \alpha * x_{22} & \cdots & \alpha * x_{2m} \\
			\vdots & \vdots & \ddots & \vdots \\
			\alpha * x_{n1} & \alpha * x_{n2} & \cdots & \alpha * x_{nm} \\
			\end{bmatrix}
			$$
		</p>
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			La definición de esta función sería formalmente
		</p>

		<p class="fragment">
			$$productoEscalar : \mathbb{R} \times \mathbb{R}^{**} \rightarrow \mathbb{R}^{**}$$
			$$(a, X) \rightarrow Y$$
		</p>

		<p class="fragment">
			donde, \(Y_{ij} = \alpha * X_{ij}\)
			<br>
			$$\forall_i = 1, 2, \dots, n$$
			$$\forall_j = 1, 2, \dots, m$$
		</p>
	</section>

	<section data-markdown>
		## Arreglos Multidimensionales: Ejemplo en Python

```python
def productoEscalar(a, X):
	n = len(X)
	m = len(X[0])
	Y = [[0] * m for i in range(n)]
	for i in range(n):
	    for j in range(m):
	        Y[i][j] = a * X[i][j]
	return Y

n = 3
m = 3
X = [[0] * m for i in range(n)]

a = float(input("Ingrese el alfa: \t"))
for i in range(n):
    for j in range(m):
        X[i][j] = float(input("Ingrese el componente de la " +
            "posición (" + str(i) + ", " + str(j) + "): \t"))

Y = productoEscalar(a, X);

print("El producto escalar es: ")
print(Y)
```
	</section>

	<section>
		<h2>Arreglos Multidimensionales: Ejemplo</h2>

		<p>
			En el caso de C++ deberemos pasar como argumento las dimensiones de la matriz, así:
		</p>

		<p class="fragment">
			$$productoEscalar : \mathbb{R} \times \mathbb{R}^{**} \times \mathbb{Z} \times \mathbb{Z} \rightarrow \mathbb{R}^{**}$$
			$$(a, X, n, m) \rightarrow Y$$
		</p>
	</section>

	<section data-markdown>
		## Arreglos Multidimensionales: Ejemplo en C++

```cpp
#include &lt;iostream&gt;

using namespace std;

float** productoEscalar(float a, float** X, int n, int m)
{
	float** Y = new float*[n];
	for(int i = 0; i < n; i++)
	    Y[i] = new float[m];

	for(int i = 0; i < n; i++)
	{
	    for(int j = 0; j < m; j++)
	    {
	        Y[i][j] = a * X[i][j];
	    }
	}
	return Y;
}

int main()
{
	int n = 3;
	int m = 3;
	float** X = new float*[n];
	for(int i = 0; i < n; i++)
	    X[i] = new float[m];
	float a = 0;
	float** Y = NULL;

	cout << "Ingrese el alfa: \t";
	cin >> a;
	
	for(int i = 0; i < n; i++)
	{
	    for(int j = 0; j < m; j++)
	    {
	        cout << "Ingrese el componente de la posición (";
	        cout << i << ", " << j << "): \t";
	        cin >> X[i][j];
	    }
	}

	Y = productoEscalar(a, X, n, m);
	
	cout << "El producto escalar es: " << endl;
	for(int i = 0; i < n; i++)
	{
	    for(int j = 0; j < m; j++)
	    {
	        cout << Y[i][j];
	    }
	    cout << endl;
	}

	return 0;
}
```
	</section>
</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				// Display controls in the bottom right corner
				controls: true,

				// Display a presentation progress bar
				progress: false,

				// Display the page number of the current slide
				slideNumber: true,

				// Push each slide change to the browser history
				history: true,

				// Enable keyboard shortcuts for navigation
				keyboard: true,

				// Enable the slide overview mode
				overview: true,

				// Vertical centering of slides
				center: true,

				// Enables touch navigation on devices with touch input
				touch: true,

				// Loop the presentation
				loop: false,

				// Change the presentation direction to be RTL
				rtl: false,

				// Turns fragments on and off globally
				fragments: true,

				// Flags if the presentation is running in an embedded mode,
				// i.e. contained within a limited portion of the screen
				embedded: false,

				// Flags if we should show a help overlay when the questionmark
				// key is pressed
				help: true,

				// Number of milliseconds between automatically proceeding to the
				// next slide, disabled when set to 0, this value can be overwritten
				// by using a data-autoslide attribute on your slides
				autoSlide: 0,

				// Stop auto-sliding after user input
				autoSlideStoppable: true,

				// Enable slide navigation via mouse wheel
				mouseWheel: false,

				// Hides the address bar on mobile devices
				hideAddressBar: true,

				// Opens links in an iframe preview overlay
				previewLinks: false,

				// Transition style
				transition: 'slide', // default/none/fade/slide/convex/concave/zoom

				// Transition speed
				transitionSpeed: 'default', // default/fast/slow

				// Transition style for full page slide backgrounds
				backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

				// Number of slides away from the current that are visible
				viewDistance: 3,

				// Parallax background image
				parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

				// Parallax background size
				parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

				// Optional reveal.js plugins
				dependencies: [
				// Cross-browser shim that fully implements classList - https://github.com/eligrey/classList.js/
				{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },

				// Interpret Markdown in <section> elements
				{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
				{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },

				// Syntax highlight for <code> elements
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },

				// Zoom in and out with Alt+click
				{ src: 'plugin/zoom-js/zoom.js', async: true },

				// Speaker notes
				{ src: 'plugin/notes/notes.js', async: true },

				// Remote control your reveal.js presentation using a touch device
				{ src: 'plugin/remotes/remotes.js', async: true },

				// MathJax
				{ src: 'plugin/math/math.js', async: true }
				]
			});

		</script>

	</body>
</html>